/* ${self.output_basename}.c
 *
 * Generated by pygi-codegen with the following command line:
 *     ${self.command_line}
*/
#include "${self.output_basename}.h"
#include "${self.output_basename}-custom.h"

#if PY_MAJOR_VERSION < 3
#    define PyLong_Type PyInt_Type
#endif

#define PYGI_CODEGEN_ENUM_VALUE_NAMES "_value_names"

static int
pygi_codegen_boolean_from_py (PyObject *obj, int *value)
{
    *value = PyObject_IsTrue (obj);
    return 1;
}

static PyObject *
pygi_codegen_boolean_to_py (int *value)
{
    if (*value)
        Py_RETURN_TRUE;
    else
        Py_RETURN_FALSE;
}


static int
pygi_codegen_interface_from_py (PyObject *obj, int *value)
{
    *value = PyObject_IsTrue (obj);
    return 1;
}

static int
pygi_codegen_enum_add_value (PyTypeObject *enum_type, PyObject *value_names,
                             const char *name, int value)
{
    int res;
    PyObject *py_value = PyObject_CallFunction ((PyObject *)enum_type, "i", value);
    if (py_value == NULL)
        return -1;
    res = PyDict_SetItemString (enum_type->tp_dict, name, py_value);

    if (res == 0 && value_names) {
        PyObject *py_value_name = PyUnicode_FromString (name);
        if (py_value_name == NULL) {
            res = -1;
        } else {
            PyDict_SetItem (value_names, py_value, py_value_name);
            Py_DECREF (py_value_name);
        }
    }

    Py_DECREF (py_value);
    return res;
}

static PyObject *
pygi_codegen_enum_repr (PyObject *self)
{
    PyObject *name;
    PyObject *value_names = PyDict_GetItemString (self->ob_type->tp_dict,
                                                  PYGI_CODEGEN_ENUM_VALUE_NAMES);
    if (value_names == NULL)
        return NULL;

    name = PyDict_GetItem (value_names, self);
    if (name == NULL)
        return NULL;

    return PyUnicode_FromFormat ("%s.%U", self->ob_type->tp_name, name);
}

#if 0
static PyObject *
pygi_codegen_flags_repr (PyObject *self)
{
    unsigned long self_value;
    unsigned long remaining_value;
    Py_ssize_t i;
    PyObject *name;
    PyObject *result;
    PyObject *result_list;
    PyObject *values;
    PyObject *value_names;

    value_names = PyDict_GetItemString (self->ob_type->tp_dict, "__flags_values__");
    if (value_names == NULL)
        return NULL;

    values = PyDict_Values (value_names);
    if (values == NULL)
        return NULL;

    /* Iterate through all enum values and test it against self as
     * to whether or not it is part of this value.
     */
    self_value = PyLong_AsUnsignedLong (self);
    remaining_value = self_value;
    result_list = PyList_New (0);

    for (i = 0; i < PyList_GET_SIZE (values); i++) {
        PyObject *value = PyList_GET_ITEM (values, i);
        unsigned long item_value = PyLong_AsUnsignedLong (value);

        if (item_value & self_value) {
            name = PyDict_GetItem (value_names, self);
            if (name == NULL)
                return NULL;

            // return PyUnicode_FromFormat ("%s.%U", self->ob_type->tp_name, name);
        }
    }

    result = PyUnicode_FromString ("");
    return result;
}
#endif


$python{
    from gi.codegen.codegen import current_context as self
    from gi.codegen.codegen import magic_print, method_table_template

    for builder in self.class_builders:
        magic_print("/* ========== ${builder.namespace}.${builder.name} ========== */")
        builder.print_converters()
        builder.print_methods()

    for builder in self.method_builders:
        builder.print_wrapper_def()

    magic_print(method_table_template)
}end


static struct PyModuleDef ${self.namespace_lower}_module_def = {
    PyModuleDef_HEAD_INIT,
    "${self.namespace}",
    NULL,
    -1,
    ${self.tp_methods},
    NULL,
    NULL,
    NULL,
    NULL
};

static int
${self.namespace_lower}_register_types (PyObject *module)
{
    $python{
        for builder in self.class_builders:
            builder.print_type_registration()
    }end

    return 0;
}

PyObject *
${self.namespace_lower}_create_module (void)
{
    PyObject *module = PyModule_Create (&${self.namespace_lower}_module_def);
    if (module == NULL)
        return NULL;

    if (${self.namespace_lower}_register_types (module)) {
        Py_DECREF (module);
        return NULL;
    }

    return module;
}
