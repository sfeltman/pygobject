/* pygirepository.c
 *
 * Generated by pygi-codegen with the following command line:
 *     ./tools/pygi-codegen GIRepository -t ./gi/codegen/cpython.template.c -o ./gi/pygirepository.c
*/
#include "pygirepository.h"
#include "pygirepository-custom.h"

#if PY_MAJOR_VERSION < 3
#    define PyLong_Type PyInt_Type
#endif

#define PYGI_CODEGEN_ENUM_VALUE_NAMES "_value_names"

static int
pygi_codegen_boolean_from_py (PyObject *obj, int *value)
{
    *value = PyObject_IsTrue (obj);
    return 1;
}

static PyObject *
pygi_codegen_boolean_to_py (int *value)
{
    if (*value)
        Py_RETURN_TRUE;
    else
        Py_RETURN_FALSE;
}


static int
pygi_codegen_interface_from_py (PyObject *obj, int *value)
{
    *value = PyObject_IsTrue (obj);
    return 1;
}

static int
pygi_codegen_enum_add_value (PyTypeObject *enum_type, PyObject *value_names,
                             const char *name, int value)
{
    int res;
    PyObject *py_value = PyObject_CallFunction ((PyObject *)enum_type, "i", value);
    if (py_value == NULL)
        return -1;
    res = PyDict_SetItemString (enum_type->tp_dict, name, py_value);

    if (res == 0 && value_names) {
        PyObject *py_value_name = PyUnicode_FromString (name);
        if (py_value_name == NULL) {
            res = -1;
        } else {
            PyDict_SetItem (value_names, py_value, py_value_name);
            Py_DECREF (py_value_name);
        }
    }

    Py_DECREF (py_value);
    return res;
}

static PyObject *
pygi_codegen_enum_repr (PyObject *self)
{
    PyObject *name;
    PyObject *value_names = PyDict_GetItemString (self->ob_type->tp_dict,
                                                  PYGI_CODEGEN_ENUM_VALUE_NAMES);
    if (value_names == NULL)
        return NULL;

    name = PyDict_GetItem (value_names, self);
    if (name == NULL)
        return NULL;

    return PyUnicode_FromFormat ("%s.%U", self->ob_type->tp_name, name);
}

#if 0
static PyObject *
pygi_codegen_flags_repr (PyObject *self)
{
    unsigned long self_value;
    unsigned long remaining_value;
    Py_ssize_t i;
    PyObject *name;
    PyObject *result;
    PyObject *result_list;
    PyObject *values;
    PyObject *value_names;

    value_names = PyDict_GetItemString (self->ob_type->tp_dict, "__flags_values__");
    if (value_names == NULL)
        return NULL;

    values = PyDict_Values (value_names);
    if (values == NULL)
        return NULL;

    /* Iterate through all enum values and test it against self as
     * to whether or not it is part of this value.
     */
    self_value = PyLong_AsUnsignedLong (self);
    remaining_value = self_value;
    result_list = PyList_New (0);

    for (i = 0; i < PyList_GET_SIZE (values); i++) {
        PyObject *value = PyList_GET_ITEM (values, i);
        unsigned long item_value = PyLong_AsUnsignedLong (value);

        if (item_value & self_value) {
            name = PyDict_GetItem (value_names, self);
            if (name == NULL)
                return NULL;

            // return PyUnicode_FromFormat ("%s.%U", self->ob_type->tp_name, name);
        }
    }

    result = PyUnicode_FromString ("");
    return result;
}
#endif


/* ========== GIRepository.ArrayType ========== */


static PyMethodDef PyGIRepositoryArrayType_methods[] = {
    #ifdef PY_GI_REPOSITORY_ARRAY_TYPE_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_ARRAY_TYPE_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryArrayType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.ArrayType",
    /* .tp_size = */ sizeof(PyGIRepositoryArrayType),
};

/* ========== GIRepository.AttributeIter ========== */

static int
attributeiter_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepositoryAttributeIter_get (obj);
    return 1;
}

static PyObject *
attributeiter_to_py (void* value)
{
    PyGIRepositoryAttributeIter *obj;
    obj = PyObject_New(PyGIRepositoryAttributeIter, &PyGIRepositoryAttributeIter_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepositoryAttributeIter_methods[] = {
    #ifdef PY_GI_REPOSITORY_ATTRIBUTE_ITER_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_ATTRIBUTE_ITER_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryAttributeIter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.AttributeIter",
    /* .tp_size = */ sizeof(PyGIRepositoryAttributeIter),
};

/* ========== GIRepository.BaseInfo ========== */

static int
baseinfo_from_py (PyObject *obj, GIBaseInfo* *value)
{
    *value = PyGIRepositoryBaseInfo_get (obj);
    return 1;
}

static PyObject *
baseinfo_to_py (GIBaseInfo* value)
{
    PyGIRepositoryBaseInfo *obj;
    obj = PyObject_New(PyGIRepositoryBaseInfo, &PyGIRepositoryBaseInfo_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyObject *
pyg_base_info_equal (PyGIRepositoryBaseInfo *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info2", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info2;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:equal", kwlist,
                                      baseinfo_from_py, &info2))
        return NULL;

    res = g_base_info_equal (self->obj, info2);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_base_info_get_attribute (PyGIRepositoryBaseInfo *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    const char* res;
    PyObject *py_res = NULL;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_attribute", kwlist,
                                      &name))
        return NULL;

    res = g_base_info_get_attribute (self->obj, name);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_base_info_get_container (PyGIRepositoryBaseInfo *self)
{
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    res = g_base_info_get_container (self->obj);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_base_info_get_name (PyGIRepositoryBaseInfo *self)
{
    const char* res;
    PyObject *py_res = NULL;
    res = g_base_info_get_name (self->obj);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_base_info_get_namespace (PyGIRepositoryBaseInfo *self)
{
    const char* res;
    PyObject *py_res = NULL;
    res = g_base_info_get_namespace (self->obj);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_base_info_get_type (PyGIRepositoryBaseInfo *self)
{
    unsigned int res;
    PyObject *py_res = NULL;
    res = g_base_info_get_type (self->obj);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_base_info_get_typelib (PyGIRepositoryBaseInfo *self)
{
    void* res;
    PyObject *py_res = NULL;
    res = g_base_info_get_typelib (self->obj);
    py_res = Py_BuildValue ("O&", typelib_to_py, &res);
    return py_res;
}


static PyObject *
pyg_base_info_is_deprecated (PyGIRepositoryBaseInfo *self)
{
    int res;
    PyObject *py_res = NULL;
    res = g_base_info_is_deprecated (self->obj);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_base_info_iterate_attributes (PyGIRepositoryBaseInfo *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iterator", "name", "value", NULL };
    int res;
    PyObject *py_res = NULL;
    void* iterator;
    const char* name;
    const char* value;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&ss:iterate_attributes", kwlist,
                                      attributeiter_from_py, &iterator, &name, &value))
        return NULL;

    res = g_base_info_iterate_attributes (self->obj, iterator, name, value);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyMethodDef PyGIRepositoryBaseInfo_methods[] = {
    { "equal", (PyCFunction) pyg_base_info_equal, METH_VARARGS | METH_KEYWORDS },
    { "get_attribute", (PyCFunction) pyg_base_info_get_attribute, METH_VARARGS | METH_KEYWORDS },
    { "get_container", (PyCFunction) pyg_base_info_get_container, METH_NOARGS },
    { "get_name", (PyCFunction) pyg_base_info_get_name, METH_NOARGS },
    { "get_namespace", (PyCFunction) pyg_base_info_get_namespace, METH_NOARGS },
    { "get_type", (PyCFunction) pyg_base_info_get_type, METH_NOARGS },
    { "get_typelib", (PyCFunction) pyg_base_info_get_typelib, METH_NOARGS },
    { "is_deprecated", (PyCFunction) pyg_base_info_is_deprecated, METH_NOARGS },
    { "iterate_attributes", (PyCFunction) pyg_base_info_iterate_attributes, METH_VARARGS | METH_KEYWORDS },
    #ifdef PY_GI_REPOSITORY_BASE_INFO_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_BASE_INFO_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryBaseInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.BaseInfo",
    /* .tp_size = */ sizeof(PyGIRepositoryBaseInfo),
};

/* ========== GIRepository.Direction ========== */


static PyMethodDef PyGIRepositoryDirection_methods[] = {
    #ifdef PY_GI_REPOSITORY_DIRECTION_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_DIRECTION_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryDirection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.Direction",
    /* .tp_size = */ sizeof(PyGIRepositoryDirection),
};

/* ========== GIRepository.FieldInfoFlags ========== */


static PyMethodDef PyGIRepositoryFieldInfoFlags_methods[] = {
    #ifdef PY_GI_REPOSITORY_FIELD_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_FIELD_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryFieldInfoFlags_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.FieldInfoFlags",
    /* .tp_size = */ sizeof(PyGIRepositoryFieldInfoFlags),
};

/* ========== GIRepository.FunctionInfoFlags ========== */


static PyMethodDef PyGIRepositoryFunctionInfoFlags_methods[] = {
    #ifdef PY_GI_REPOSITORY_FUNCTION_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_FUNCTION_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryFunctionInfoFlags_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.FunctionInfoFlags",
    /* .tp_size = */ sizeof(PyGIRepositoryFunctionInfoFlags),
};

/* ========== GIRepository.InfoType ========== */


static PyMethodDef PyGIRepositoryInfoType_methods[] = {
    #ifdef PY_GI_REPOSITORY_INFO_TYPE_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_INFO_TYPE_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryInfoType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.InfoType",
    /* .tp_size = */ sizeof(PyGIRepositoryInfoType),
};

/* ========== GIRepository.Repository ========== */

static int
repository_from_py (PyObject *obj, GIRepository* *value)
{
    *value = PyGIRepositoryRepository_get (obj);
    return 1;
}

static PyObject *
repository_to_py (GIRepository* value)
{
    PyGIRepositoryRepository *obj;
    obj = PyObject_New(PyGIRepositoryRepository, &PyGIRepositoryRepository_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyObject *
pyg_irepository_dump (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arg", NULL };
    int res;
    PyObject *py_res = NULL;
    GError *error = NULL;
    const char* arg;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:dump", kwlist,
                                      &arg))
        return NULL;

    res = g_irepository_dump (arg, &error);

    if (error != NULL) {
        PyErr_SetString (PyExc_ValueError, error->message);
        g_error_free (error);
        return NULL;
    }
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_error_quark (PyGIRepositoryRepository *self)
{
    unsigned int res;
    PyObject *py_res = NULL;
    res = g_irepository_error_quark ();
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_irepository_get_default (PyGIRepositoryRepository *self)
{
    GIRepository* res;
    PyObject *py_res = NULL;
    res = g_irepository_get_default ();
    py_res = Py_BuildValue ("O&", repository_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_get_search_path (PyGIRepositoryRepository *self)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 18");
    return NULL;
}


static PyObject *
pyg_irepository_prepend_library_path (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "directory", NULL };
    const char* directory;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:prepend_library_path", kwlist,
                                      &directory))
        return NULL;

    g_irepository_prepend_library_path (directory);
    Py_RETURN_NONE;
}


static PyObject *
pyg_irepository_prepend_search_path (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "directory", NULL };
    const char* directory;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:prepend_search_path", kwlist,
                                      &directory))
        return NULL;

    g_irepository_prepend_search_path (directory);
    Py_RETURN_NONE;
}


static PyObject *
pyg_irepository_enumerate_versions (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 17");
    return NULL;
}


static PyObject *
pyg_irepository_find_by_error_domain (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "domain", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    unsigned int domain;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "I:find_by_error_domain", kwlist,
                                      &domain))
        return NULL;

    res = g_irepository_find_by_error_domain (self->obj, domain);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_find_by_gtype (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 12");
    return NULL;
}


static PyObject *
pyg_irepository_find_by_name (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    const char* namespace_;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "ss:find_by_name", kwlist,
                                      &namespace_, &name))
        return NULL;

    res = g_irepository_find_by_name (self->obj, namespace_, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_get_c_prefix (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", NULL };
    const char* res;
    PyObject *py_res = NULL;
    const char* namespace_;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_c_prefix", kwlist,
                                      &namespace_))
        return NULL;

    res = g_irepository_get_c_prefix (self->obj, namespace_);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_irepository_get_dependencies (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 15");
    return NULL;
}


static PyObject *
pyg_irepository_get_info (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", "index", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    const char* namespace_;
    signed int index;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "si:get_info", kwlist,
                                      &namespace_, &index))
        return NULL;

    res = g_irepository_get_info (self->obj, namespace_, index);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_get_loaded_namespaces (PyGIRepositoryRepository *self)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 15");
    return NULL;
}


static PyObject *
pyg_irepository_get_n_infos (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", NULL };
    signed int res;
    PyObject *py_res = NULL;
    const char* namespace_;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_n_infos", kwlist,
                                      &namespace_))
        return NULL;

    res = g_irepository_get_n_infos (self->obj, namespace_);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_irepository_get_shared_library (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", NULL };
    const char* res;
    PyObject *py_res = NULL;
    const char* namespace_;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_shared_library", kwlist,
                                      &namespace_))
        return NULL;

    res = g_irepository_get_shared_library (self->obj, namespace_);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_irepository_get_typelib_path (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", NULL };
    const char* res;
    PyObject *py_res = NULL;
    const char* namespace_;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_typelib_path", kwlist,
                                      &namespace_))
        return NULL;

    res = g_irepository_get_typelib_path (self->obj, namespace_);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_irepository_get_version (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", NULL };
    const char* res;
    PyObject *py_res = NULL;
    const char* namespace_;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "s:get_version", kwlist,
                                      &namespace_))
        return NULL;

    res = g_irepository_get_version (self->obj, namespace_);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_irepository_is_registered (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", "version", NULL };
    int res;
    PyObject *py_res = NULL;
    const char* namespace_;
    const char* version;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "ss:is_registered", kwlist,
                                      &namespace_, &version))
        return NULL;

    res = g_irepository_is_registered (self->obj, namespace_, version);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_load_typelib (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "typelib", "flags", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GError *error = NULL;
    void* typelib;
    unsigned int flags;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&I:load_typelib", kwlist,
                                      typelib_from_py, &typelib, &flags))
        return NULL;

    res = g_irepository_load_typelib (self->obj, typelib, flags, &error);

    if (error != NULL) {
        PyErr_SetString (PyExc_ValueError, error->message);
        g_error_free (error);
        return NULL;
    }
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_irepository_require (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "namespace_", "version", "flags", NULL };
    void* res;
    PyObject *py_res = NULL;
    GError *error = NULL;
    const char* namespace_;
    const char* version;
    unsigned int flags;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "ssI:require", kwlist,
                                      &namespace_, &version, &flags))
        return NULL;

    res = g_irepository_require (self->obj, namespace_, version, flags, &error);

    if (error != NULL) {
        PyErr_SetString (PyExc_ValueError, error->message);
        g_error_free (error);
        return NULL;
    }
    py_res = Py_BuildValue ("O&", typelib_to_py, &res);
    return py_res;
}


static PyObject *
pyg_irepository_require_private (PyGIRepositoryRepository *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "typelib_dir", "namespace_", "version", "flags", NULL };
    void* res;
    PyObject *py_res = NULL;
    GError *error = NULL;
    const char* typelib_dir;
    const char* namespace_;
    const char* version;
    unsigned int flags;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "sssI:require_private", kwlist,
                                      &typelib_dir, &namespace_, &version, &flags))
        return NULL;

    res = g_irepository_require_private (self->obj, typelib_dir, namespace_, version, flags, &error);

    if (error != NULL) {
        PyErr_SetString (PyExc_ValueError, error->message);
        g_error_free (error);
        return NULL;
    }
    py_res = Py_BuildValue ("O&", typelib_to_py, &res);
    return py_res;
}


static PyMethodDef PyGIRepositoryRepository_methods[] = {
    { "dump", (PyCFunction) pyg_irepository_dump, METH_VARARGS | METH_KEYWORDS | METH_STATIC },
    { "error_quark", (PyCFunction) pyg_irepository_error_quark, METH_NOARGS | METH_STATIC },
    { "get_default", (PyCFunction) pyg_irepository_get_default, METH_NOARGS | METH_STATIC },
    { "get_search_path", (PyCFunction) pyg_irepository_get_search_path, METH_NOARGS | METH_STATIC },
    { "prepend_library_path", (PyCFunction) pyg_irepository_prepend_library_path, METH_VARARGS | METH_KEYWORDS | METH_STATIC },
    { "prepend_search_path", (PyCFunction) pyg_irepository_prepend_search_path, METH_VARARGS | METH_KEYWORDS | METH_STATIC },
    { "enumerate_versions", (PyCFunction) pyg_irepository_enumerate_versions, METH_VARARGS | METH_KEYWORDS },
    { "find_by_error_domain", (PyCFunction) pyg_irepository_find_by_error_domain, METH_VARARGS | METH_KEYWORDS },
    { "find_by_gtype", (PyCFunction) pyg_irepository_find_by_gtype, METH_VARARGS | METH_KEYWORDS },
    { "find_by_name", (PyCFunction) pyg_irepository_find_by_name, METH_VARARGS | METH_KEYWORDS },
    { "get_c_prefix", (PyCFunction) pyg_irepository_get_c_prefix, METH_VARARGS | METH_KEYWORDS },
    { "get_dependencies", (PyCFunction) pyg_irepository_get_dependencies, METH_VARARGS | METH_KEYWORDS },
    { "get_info", (PyCFunction) pyg_irepository_get_info, METH_VARARGS | METH_KEYWORDS },
    { "get_loaded_namespaces", (PyCFunction) pyg_irepository_get_loaded_namespaces, METH_NOARGS },
    { "get_n_infos", (PyCFunction) pyg_irepository_get_n_infos, METH_VARARGS | METH_KEYWORDS },
    { "get_shared_library", (PyCFunction) pyg_irepository_get_shared_library, METH_VARARGS | METH_KEYWORDS },
    { "get_typelib_path", (PyCFunction) pyg_irepository_get_typelib_path, METH_VARARGS | METH_KEYWORDS },
    { "get_version", (PyCFunction) pyg_irepository_get_version, METH_VARARGS | METH_KEYWORDS },
    { "is_registered", (PyCFunction) pyg_irepository_is_registered, METH_VARARGS | METH_KEYWORDS },
    { "load_typelib", (PyCFunction) pyg_irepository_load_typelib, METH_VARARGS | METH_KEYWORDS },
    { "require", (PyCFunction) pyg_irepository_require, METH_VARARGS | METH_KEYWORDS },
    { "require_private", (PyCFunction) pyg_irepository_require_private, METH_VARARGS | METH_KEYWORDS },
    #ifdef PY_GI_REPOSITORY_REPOSITORY_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_REPOSITORY_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryRepository_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.Repository",
    /* .tp_size = */ sizeof(PyGIRepositoryRepository),
};

/* ========== GIRepository.RepositoryClass ========== */

static int
repositoryclass_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepositoryRepositoryClass_get (obj);
    return 1;
}

static PyObject *
repositoryclass_to_py (void* value)
{
    PyGIRepositoryRepositoryClass *obj;
    obj = PyObject_New(PyGIRepositoryRepositoryClass, &PyGIRepositoryRepositoryClass_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepositoryRepositoryClass_methods[] = {
    #ifdef PY_GI_REPOSITORY_REPOSITORY_CLASS_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_REPOSITORY_CLASS_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryRepositoryClass_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.RepositoryClass",
    /* .tp_size = */ sizeof(PyGIRepositoryRepositoryClass),
};

/* ========== GIRepository.RepositoryError ========== */


static PyMethodDef PyGIRepositoryRepositoryError_methods[] = {
    #ifdef PY_GI_REPOSITORY_REPOSITORY_ERROR_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_REPOSITORY_ERROR_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryRepositoryError_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.RepositoryError",
    /* .tp_size = */ sizeof(PyGIRepositoryRepositoryError),
};

/* ========== GIRepository.RepositoryLoadFlags ========== */


static PyMethodDef PyGIRepositoryRepositoryLoadFlags_methods[] = {
    #ifdef PY_GI_REPOSITORY_REPOSITORY_LOAD_FLAGS_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_REPOSITORY_LOAD_FLAGS_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryRepositoryLoadFlags_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.RepositoryLoadFlags",
    /* .tp_size = */ sizeof(PyGIRepositoryRepositoryLoadFlags),
};

/* ========== GIRepository.RepositoryPrivate ========== */

static int
repositoryprivate_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepositoryRepositoryPrivate_get (obj);
    return 1;
}

static PyObject *
repositoryprivate_to_py (void* value)
{
    PyGIRepositoryRepositoryPrivate *obj;
    obj = PyObject_New(PyGIRepositoryRepositoryPrivate, &PyGIRepositoryRepositoryPrivate_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepositoryRepositoryPrivate_methods[] = {
    #ifdef PY_GI_REPOSITORY_REPOSITORY_PRIVATE_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_REPOSITORY_PRIVATE_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryRepositoryPrivate_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.RepositoryPrivate",
    /* .tp_size = */ sizeof(PyGIRepositoryRepositoryPrivate),
};

/* ========== GIRepository.ScopeType ========== */


static PyMethodDef PyGIRepositoryScopeType_methods[] = {
    #ifdef PY_GI_REPOSITORY_SCOPE_TYPE_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_SCOPE_TYPE_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryScopeType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.ScopeType",
    /* .tp_size = */ sizeof(PyGIRepositoryScopeType),
};

/* ========== GIRepository.Transfer ========== */


static PyMethodDef PyGIRepositoryTransfer_methods[] = {
    #ifdef PY_GI_REPOSITORY_TRANSFER_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_TRANSFER_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryTransfer_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.Transfer",
    /* .tp_size = */ sizeof(PyGIRepositoryTransfer),
};

/* ========== GIRepository.TypeTag ========== */


static PyMethodDef PyGIRepositoryTypeTag_methods[] = {
    #ifdef PY_GI_REPOSITORY_TYPE_TAG_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_TYPE_TAG_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryTypeTag_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.TypeTag",
    /* .tp_size = */ sizeof(PyGIRepositoryTypeTag),
};

/* ========== GIRepository.Typelib ========== */

static int
typelib_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepositoryTypelib_get (obj);
    return 1;
}

static PyObject *
typelib_to_py (void* value)
{
    PyGIRepositoryTypelib *obj;
    obj = PyObject_New(PyGIRepositoryTypelib, &PyGIRepositoryTypelib_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyObject *
pyg_typelib_free (PyGIRepositoryTypelib *self)
{
    g_typelib_free (self->obj);
    Py_RETURN_NONE;
}


static PyObject *
pyg_typelib_get_namespace (PyGIRepositoryTypelib *self)
{
    const char* res;
    PyObject *py_res = NULL;
    res = g_typelib_get_namespace (self->obj);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_typelib_symbol (PyGIRepositoryTypelib *self, PyObject *args, PyObject *kwargs)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 0");
    return NULL;
}


static PyMethodDef PyGIRepositoryTypelib_methods[] = {
    { "free", (PyCFunction) pyg_typelib_free, METH_NOARGS },
    { "get_namespace", (PyCFunction) pyg_typelib_get_namespace, METH_NOARGS },
    { "symbol", (PyCFunction) pyg_typelib_symbol, METH_VARARGS | METH_KEYWORDS },
    #ifdef PY_GI_REPOSITORY_TYPELIB_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_TYPELIB_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryTypelib_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.Typelib",
    /* .tp_size = */ sizeof(PyGIRepositoryTypelib),
};

/* ========== GIRepository.UnresolvedInfo ========== */

static int
unresolvedinfo_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepositoryUnresolvedInfo_get (obj);
    return 1;
}

static PyObject *
unresolvedinfo_to_py (void* value)
{
    PyGIRepositoryUnresolvedInfo *obj;
    obj = PyObject_New(PyGIRepositoryUnresolvedInfo, &PyGIRepositoryUnresolvedInfo_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepositoryUnresolvedInfo_methods[] = {
    #ifdef PY_GI_REPOSITORY_UNRESOLVED_INFO_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_UNRESOLVED_INFO_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryUnresolvedInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.UnresolvedInfo",
    /* .tp_size = */ sizeof(PyGIRepositoryUnresolvedInfo),
};

/* ========== GIRepository.VFuncInfoFlags ========== */


static PyMethodDef PyGIRepositoryVFuncInfoFlags_methods[] = {
    #ifdef PY_GI_REPOSITORY_V_FUNC_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY_V_FUNC_INFO_FLAGS_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositoryVFuncInfoFlags_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.VFuncInfoFlags",
    /* .tp_size = */ sizeof(PyGIRepositoryVFuncInfoFlags),
};

/* ========== GIRepository._Argument ========== */

static int
_argument_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepository_Argument_get (obj);
    return 1;
}

static PyObject *
_argument_to_py (void* value)
{
    PyGIRepository_Argument *obj;
    obj = PyObject_New(PyGIRepository_Argument, &PyGIRepository_Argument_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepository_Argument_methods[] = {
    #ifdef PY_GI_REPOSITORY__ARGUMENT_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY__ARGUMENT_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepository_Argument_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository._Argument",
    /* .tp_size = */ sizeof(PyGIRepository_Argument),
};

/* ========== GIRepository._BaseInfoStub ========== */

static int
_baseinfostub_from_py (PyObject *obj, void* *value)
{
    *value = PyGIRepository_BaseInfoStub_get (obj);
    return 1;
}

static PyObject *
_baseinfostub_to_py (void* value)
{
    PyGIRepository_BaseInfoStub *obj;
    obj = PyObject_New(PyGIRepository_BaseInfoStub, &PyGIRepository_BaseInfoStub_Type);
    obj->obj = value;
    return (PyObject *) obj;
}


static PyMethodDef PyGIRepository_BaseInfoStub_methods[] = {
    #ifdef PY_GI_REPOSITORY__BASE_INFO_STUB_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORY__BASE_INFO_STUB_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepository_BaseInfoStub_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository._BaseInfoStub",
    /* .tp_size = */ sizeof(PyGIRepository_BaseInfoStub),
};

/* ========== GIRepository.nvokeError ========== */


static PyMethodDef PyGIRepositorynvokeError_methods[] = {
    #ifdef PY_GI_REPOSITORYNVOKE_ERROR_METHODS_CUSTOM_ENTRIES
        PY_GI_REPOSITORYNVOKE_ERROR_METHODS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};


PyTypeObject PyGIRepositorynvokeError_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    /* .tp_name = */ "GIRepository.nvokeError",
    /* .tp_size = */ sizeof(PyGIRepositorynvokeError),
};


static PyObject *
pyg_arg_info_get_closure (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_closure", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_closure (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_arg_info_get_destroy (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_destroy", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_destroy (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_arg_info_get_direction (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_direction", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_direction (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_arg_info_get_ownership_transfer (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_ownership_transfer", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_ownership_transfer (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_arg_info_get_scope (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_scope", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_scope (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_arg_info_get_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_get_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_get_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_arg_info_is_caller_allocates (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_is_caller_allocates", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_is_caller_allocates (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_arg_info_is_optional (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_is_optional", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_is_optional (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_arg_info_is_return_value (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_is_return_value", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_is_return_value (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_arg_info_is_skip (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_is_skip", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_is_skip (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_arg_info_load_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "type", NULL };
    GIBaseInfo* info;
    GIBaseInfo* type;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&O&:arg_info_load_type", kwlist,
                                      baseinfo_from_py, &info, baseinfo_from_py, &type))
        return NULL;

    g_arg_info_load_type (info, type);
    Py_RETURN_NONE;
}


static PyObject *
pyg_arg_info_may_be_null (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:arg_info_may_be_null", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_arg_info_may_be_null (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_can_throw_gerror (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_can_throw_gerror", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_can_throw_gerror (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_get_arg (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:callable_info_get_arg", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_callable_info_get_arg (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_get_caller_owns (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_get_caller_owns", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_get_caller_owns (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_callable_info_get_n_args (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_get_n_args", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_get_n_args (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_callable_info_get_return_attribute (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:callable_info_get_return_attribute", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_callable_info_get_return_attribute (info, name);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_callable_info_get_return_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_get_return_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_get_return_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_is_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_is_method", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_is_method (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_iterate_return_attributes (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "iterator", "name", "value", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    void* iterator;
    const char* name;
    const char* value;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&O&ss:callable_info_iterate_return_attributes", kwlist,
                                      baseinfo_from_py, &info, attributeiter_from_py, &iterator, &name, &value))
        return NULL;

    res = g_callable_info_iterate_return_attributes (info, iterator, name, value);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_load_arg (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", "arg", NULL };
    GIBaseInfo* info;
    signed int n;
    GIBaseInfo* arg;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&iO&:callable_info_load_arg", kwlist,
                                      baseinfo_from_py, &info, &n, baseinfo_from_py, &arg))
        return NULL;

    g_callable_info_load_arg (info, n, arg);
    Py_RETURN_NONE;
}


static PyObject *
pyg_callable_info_load_return_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "type", NULL };
    GIBaseInfo* info;
    GIBaseInfo* type;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&O&:callable_info_load_return_type", kwlist,
                                      baseinfo_from_py, &info, baseinfo_from_py, &type))
        return NULL;

    g_callable_info_load_return_type (info, type);
    Py_RETURN_NONE;
}


static PyObject *
pyg_callable_info_may_return_null (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_may_return_null", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_may_return_null (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_callable_info_skip_return (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:callable_info_skip_return", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_callable_info_skip_return (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_constant_info_get_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:constant_info_get_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_constant_info_get_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_error_domain (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:enum_info_get_error_domain", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_enum_info_get_error_domain (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:enum_info_get_method", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_enum_info_get_method (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_n_methods (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:enum_info_get_n_methods", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_enum_info_get_n_methods (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_n_values (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:enum_info_get_n_values", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_enum_info_get_n_values (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_storage_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:enum_info_get_storage_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_enum_info_get_storage_type (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_enum_info_get_value (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:enum_info_get_value", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_enum_info_get_value (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_field_info_get_flags (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:field_info_get_flags", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_field_info_get_flags (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_field_info_get_offset (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:field_info_get_offset", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_field_info_get_offset (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_field_info_get_size (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:field_info_get_size", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_field_info_get_size (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_field_info_get_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:field_info_get_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_field_info_get_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_function_info_get_flags (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:function_info_get_flags", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_function_info_get_flags (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_function_info_get_property (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:function_info_get_property", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_function_info_get_property (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_function_info_get_symbol (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:function_info_get_symbol", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_function_info_get_symbol (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_function_info_get_vfunc (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:function_info_get_vfunc", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_function_info_get_vfunc (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_info_new (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "container", "typelib", "offset", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    unsigned int type;
    GIBaseInfo* container;
    void* typelib;
    unsigned int offset;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "IO&O&I:info_new", kwlist,
                                      &type, baseinfo_from_py, &container, typelib_from_py, &typelib, &offset))
        return NULL;

    res = g_info_new (type, container, typelib, offset);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_info_type_to_string (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    const char* res;
    PyObject *py_res = NULL;
    unsigned int type;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "I:info_type_to_string", kwlist,
                                      &type))
        return NULL;

    res = g_info_type_to_string (type);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_interface_info_find_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:interface_info_find_method", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_interface_info_find_method (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_find_signal (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:interface_info_find_signal", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_interface_info_find_signal (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_find_vfunc (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:interface_info_find_vfunc", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_interface_info_find_vfunc (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_constant (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_constant", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_constant (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_iface_struct (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_iface_struct", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_iface_struct (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_method", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_method (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_constants (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_constants", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_constants (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_methods (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_methods", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_methods (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_prerequisites (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_prerequisites", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_prerequisites (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_properties (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_properties", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_properties (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_signals (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_signals", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_signals (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_n_vfuncs (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:interface_info_get_n_vfuncs", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_interface_info_get_n_vfuncs (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_prerequisite (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_prerequisite", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_prerequisite (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_property (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_property", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_property (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_signal (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_signal", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_signal (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_interface_info_get_vfunc (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:interface_info_get_vfunc", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_interface_info_get_vfunc (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_invoke_error_quark (PyObject *self)
{
    unsigned int res;
    PyObject *py_res = NULL;
    res = g_invoke_error_quark ();
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_object_info_find_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:object_info_find_method", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_object_info_find_method (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_find_method_using_interfaces (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", "implementor", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;
    GIBaseInfo* implementor;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&sO&:object_info_find_method_using_interfaces", kwlist,
                                      baseinfo_from_py, &info, &name, baseinfo_from_py, &implementor))
        return NULL;

    res = g_object_info_find_method_using_interfaces (info, name, implementor);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_find_vfunc (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:object_info_find_vfunc", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_object_info_find_vfunc (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_find_vfunc_using_interfaces (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", "implementor", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;
    GIBaseInfo* implementor;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&sO&:object_info_find_vfunc_using_interfaces", kwlist,
                                      baseinfo_from_py, &info, &name, baseinfo_from_py, &implementor))
        return NULL;

    res = g_object_info_find_vfunc_using_interfaces (info, name, implementor);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_abstract (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_abstract", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_abstract (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_class_struct (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_class_struct", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_class_struct (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_constant (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_constant", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_constant (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_field (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_field", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_field (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_fundamental (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_fundamental", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_fundamental (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_get_value_function (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_get_value_function", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_get_value_function (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_interface (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_interface", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_interface (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_method", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_method (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_constants (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_constants", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_constants (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_fields (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_fields", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_fields (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_interfaces (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_interfaces", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_interfaces (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_methods (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_methods", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_methods (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_properties (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_properties", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_properties (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_signals (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_signals", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_signals (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_n_vfuncs (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_n_vfuncs", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_n_vfuncs (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_parent (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_parent", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_parent (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_property (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_property", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_property (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_ref_function (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_ref_function", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_ref_function (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_set_value_function (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_set_value_function", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_set_value_function (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_signal (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_signal", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_signal (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_object_info_get_type_init (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_type_init", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_type_init (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_type_name (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_type_name", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_type_name (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_unref_function (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:object_info_get_unref_function", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_object_info_get_unref_function (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_object_info_get_vfunc (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:object_info_get_vfunc", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_object_info_get_vfunc (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_property_info_get_flags (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:property_info_get_flags", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_property_info_get_flags (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_property_info_get_ownership_transfer (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:property_info_get_ownership_transfer", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_property_info_get_ownership_transfer (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_property_info_get_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:property_info_get_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_property_info_get_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_registered_type_info_get_g_type (PyObject *self, PyObject *args, PyObject *kwargs)
{

    PyErr_SetString (PyExc_NotImplementedError, "Don't know how to marshal 12");
    return NULL;
}


static PyObject *
pyg_registered_type_info_get_type_init (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:registered_type_info_get_type_init", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_registered_type_info_get_type_init (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_registered_type_info_get_type_name (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    const char* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:registered_type_info_get_type_name", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_registered_type_info_get_type_name (info);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_signal_info_get_class_closure (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:signal_info_get_class_closure", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_signal_info_get_class_closure (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_signal_info_get_flags (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:signal_info_get_flags", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_signal_info_get_flags (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_signal_info_true_stops_emit (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:signal_info_true_stops_emit", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_signal_info_true_stops_emit (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_struct_info_find_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:struct_info_find_method", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_struct_info_find_method (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_alignment (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned PY_LONG_LONG res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_get_alignment", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_get_alignment (info);
    py_res = Py_BuildValue ("K", res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_field (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:struct_info_get_field", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_struct_info_get_field (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:struct_info_get_method", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_struct_info_get_method (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_n_fields (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_get_n_fields", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_get_n_fields (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_n_methods (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_get_n_methods", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_get_n_methods (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_struct_info_get_size (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned PY_LONG_LONG res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_get_size", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_get_size (info);
    py_res = Py_BuildValue ("K", res);
    return py_res;
}


static PyObject *
pyg_struct_info_is_foreign (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_is_foreign", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_is_foreign (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_struct_info_is_gtype_struct (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:struct_info_is_gtype_struct", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_struct_info_is_gtype_struct (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_type_info_get_array_fixed_size (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_get_array_fixed_size", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_get_array_fixed_size (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_type_info_get_array_length (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_get_array_length", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_get_array_length (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_type_info_get_array_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_get_array_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_get_array_type (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_type_info_get_interface (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_get_interface", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_get_interface (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_type_info_get_param_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:type_info_get_param_type", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_type_info_get_param_type (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_type_info_get_tag (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_get_tag", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_get_tag (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_type_info_is_pointer (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_is_pointer", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_is_pointer (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_type_info_is_zero_terminated (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:type_info_is_zero_terminated", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_type_info_is_zero_terminated (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_type_tag_to_string (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    const char* res;
    PyObject *py_res = NULL;
    unsigned int type;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "I:type_tag_to_string", kwlist,
                                      &type))
        return NULL;

    res = g_type_tag_to_string (type);
    py_res = Py_BuildValue ("z", res);
    return py_res;
}


static PyObject *
pyg_union_info_find_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "name", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    const char* name;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&s:union_info_find_method", kwlist,
                                      baseinfo_from_py, &info, &name))
        return NULL;

    res = g_union_info_find_method (info, name);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_union_info_get_alignment (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned PY_LONG_LONG res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_alignment", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_alignment (info);
    py_res = Py_BuildValue ("K", res);
    return py_res;
}


static PyObject *
pyg_union_info_get_discriminator (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:union_info_get_discriminator", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_union_info_get_discriminator (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_union_info_get_discriminator_offset (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_discriminator_offset", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_discriminator_offset (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_union_info_get_discriminator_type (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_discriminator_type", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_discriminator_type (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_union_info_get_field (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:union_info_get_field", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_union_info_get_field (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_union_info_get_method (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", "n", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;
    signed int n;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&i:union_info_get_method", kwlist,
                                      baseinfo_from_py, &info, &n))
        return NULL;

    res = g_union_info_get_method (info, n);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_union_info_get_n_fields (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_n_fields", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_n_fields (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_union_info_get_n_methods (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_n_methods", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_n_methods (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_union_info_get_size (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned PY_LONG_LONG res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_get_size", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_get_size (info);
    py_res = Py_BuildValue ("K", res);
    return py_res;
}


static PyObject *
pyg_union_info_is_discriminated (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:union_info_is_discriminated", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_union_info_is_discriminated (info);
    py_res = Py_BuildValue ("O&", pygi_codegen_boolean_to_py, &res);
    return py_res;
}


static PyObject *
pyg_value_info_get_value (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    PY_LONG_LONG res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:value_info_get_value", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_value_info_get_value (info);
    py_res = Py_BuildValue ("L", res);
    return py_res;
}


static PyObject *
pyg_vfunc_info_get_flags (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    unsigned int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:vfunc_info_get_flags", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_vfunc_info_get_flags (info);
    py_res = Py_BuildValue ("I", res);
    return py_res;
}


static PyObject *
pyg_vfunc_info_get_invoker (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:vfunc_info_get_invoker", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_vfunc_info_get_invoker (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyObject *
pyg_vfunc_info_get_offset (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    signed int res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:vfunc_info_get_offset", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_vfunc_info_get_offset (info);
    py_res = Py_BuildValue ("i", res);
    return py_res;
}


static PyObject *
pyg_vfunc_info_get_signal (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info", NULL };
    GIBaseInfo* res;
    PyObject *py_res = NULL;
    GIBaseInfo* info;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O&:vfunc_info_get_signal", kwlist,
                                      baseinfo_from_py, &info))
        return NULL;

    res = g_vfunc_info_get_signal (info);
    py_res = Py_BuildValue ("O&", baseinfo_to_py, &res);
    return py_res;
}


static PyMethodDef pygirepository_functions[] = {
    { "arg_info_get_closure", (PyCFunction) pyg_arg_info_get_closure, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_get_destroy", (PyCFunction) pyg_arg_info_get_destroy, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_get_direction", (PyCFunction) pyg_arg_info_get_direction, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_get_ownership_transfer", (PyCFunction) pyg_arg_info_get_ownership_transfer, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_get_scope", (PyCFunction) pyg_arg_info_get_scope, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_get_type", (PyCFunction) pyg_arg_info_get_type, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_is_caller_allocates", (PyCFunction) pyg_arg_info_is_caller_allocates, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_is_optional", (PyCFunction) pyg_arg_info_is_optional, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_is_return_value", (PyCFunction) pyg_arg_info_is_return_value, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_is_skip", (PyCFunction) pyg_arg_info_is_skip, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_load_type", (PyCFunction) pyg_arg_info_load_type, METH_VARARGS | METH_KEYWORDS },
    { "arg_info_may_be_null", (PyCFunction) pyg_arg_info_may_be_null, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_can_throw_gerror", (PyCFunction) pyg_callable_info_can_throw_gerror, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_get_arg", (PyCFunction) pyg_callable_info_get_arg, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_get_caller_owns", (PyCFunction) pyg_callable_info_get_caller_owns, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_get_n_args", (PyCFunction) pyg_callable_info_get_n_args, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_get_return_attribute", (PyCFunction) pyg_callable_info_get_return_attribute, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_get_return_type", (PyCFunction) pyg_callable_info_get_return_type, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_is_method", (PyCFunction) pyg_callable_info_is_method, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_iterate_return_attributes", (PyCFunction) pyg_callable_info_iterate_return_attributes, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_load_arg", (PyCFunction) pyg_callable_info_load_arg, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_load_return_type", (PyCFunction) pyg_callable_info_load_return_type, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_may_return_null", (PyCFunction) pyg_callable_info_may_return_null, METH_VARARGS | METH_KEYWORDS },
    { "callable_info_skip_return", (PyCFunction) pyg_callable_info_skip_return, METH_VARARGS | METH_KEYWORDS },
    { "constant_info_get_type", (PyCFunction) pyg_constant_info_get_type, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_error_domain", (PyCFunction) pyg_enum_info_get_error_domain, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_method", (PyCFunction) pyg_enum_info_get_method, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_n_methods", (PyCFunction) pyg_enum_info_get_n_methods, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_n_values", (PyCFunction) pyg_enum_info_get_n_values, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_storage_type", (PyCFunction) pyg_enum_info_get_storage_type, METH_VARARGS | METH_KEYWORDS },
    { "enum_info_get_value", (PyCFunction) pyg_enum_info_get_value, METH_VARARGS | METH_KEYWORDS },
    { "field_info_get_flags", (PyCFunction) pyg_field_info_get_flags, METH_VARARGS | METH_KEYWORDS },
    { "field_info_get_offset", (PyCFunction) pyg_field_info_get_offset, METH_VARARGS | METH_KEYWORDS },
    { "field_info_get_size", (PyCFunction) pyg_field_info_get_size, METH_VARARGS | METH_KEYWORDS },
    { "field_info_get_type", (PyCFunction) pyg_field_info_get_type, METH_VARARGS | METH_KEYWORDS },
    { "function_info_get_flags", (PyCFunction) pyg_function_info_get_flags, METH_VARARGS | METH_KEYWORDS },
    { "function_info_get_property", (PyCFunction) pyg_function_info_get_property, METH_VARARGS | METH_KEYWORDS },
    { "function_info_get_symbol", (PyCFunction) pyg_function_info_get_symbol, METH_VARARGS | METH_KEYWORDS },
    { "function_info_get_vfunc", (PyCFunction) pyg_function_info_get_vfunc, METH_VARARGS | METH_KEYWORDS },
    { "info_new", (PyCFunction) pyg_info_new, METH_VARARGS | METH_KEYWORDS },
    { "info_type_to_string", (PyCFunction) pyg_info_type_to_string, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_find_method", (PyCFunction) pyg_interface_info_find_method, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_find_signal", (PyCFunction) pyg_interface_info_find_signal, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_find_vfunc", (PyCFunction) pyg_interface_info_find_vfunc, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_constant", (PyCFunction) pyg_interface_info_get_constant, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_iface_struct", (PyCFunction) pyg_interface_info_get_iface_struct, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_method", (PyCFunction) pyg_interface_info_get_method, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_constants", (PyCFunction) pyg_interface_info_get_n_constants, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_methods", (PyCFunction) pyg_interface_info_get_n_methods, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_prerequisites", (PyCFunction) pyg_interface_info_get_n_prerequisites, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_properties", (PyCFunction) pyg_interface_info_get_n_properties, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_signals", (PyCFunction) pyg_interface_info_get_n_signals, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_n_vfuncs", (PyCFunction) pyg_interface_info_get_n_vfuncs, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_prerequisite", (PyCFunction) pyg_interface_info_get_prerequisite, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_property", (PyCFunction) pyg_interface_info_get_property, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_signal", (PyCFunction) pyg_interface_info_get_signal, METH_VARARGS | METH_KEYWORDS },
    { "interface_info_get_vfunc", (PyCFunction) pyg_interface_info_get_vfunc, METH_VARARGS | METH_KEYWORDS },
    { "invoke_error_quark", (PyCFunction) pyg_invoke_error_quark, METH_NOARGS },
    { "object_info_find_method", (PyCFunction) pyg_object_info_find_method, METH_VARARGS | METH_KEYWORDS },
    { "object_info_find_method_using_interfaces", (PyCFunction) pyg_object_info_find_method_using_interfaces, METH_VARARGS | METH_KEYWORDS },
    { "object_info_find_vfunc", (PyCFunction) pyg_object_info_find_vfunc, METH_VARARGS | METH_KEYWORDS },
    { "object_info_find_vfunc_using_interfaces", (PyCFunction) pyg_object_info_find_vfunc_using_interfaces, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_abstract", (PyCFunction) pyg_object_info_get_abstract, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_class_struct", (PyCFunction) pyg_object_info_get_class_struct, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_constant", (PyCFunction) pyg_object_info_get_constant, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_field", (PyCFunction) pyg_object_info_get_field, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_fundamental", (PyCFunction) pyg_object_info_get_fundamental, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_get_value_function", (PyCFunction) pyg_object_info_get_get_value_function, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_interface", (PyCFunction) pyg_object_info_get_interface, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_method", (PyCFunction) pyg_object_info_get_method, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_constants", (PyCFunction) pyg_object_info_get_n_constants, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_fields", (PyCFunction) pyg_object_info_get_n_fields, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_interfaces", (PyCFunction) pyg_object_info_get_n_interfaces, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_methods", (PyCFunction) pyg_object_info_get_n_methods, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_properties", (PyCFunction) pyg_object_info_get_n_properties, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_signals", (PyCFunction) pyg_object_info_get_n_signals, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_n_vfuncs", (PyCFunction) pyg_object_info_get_n_vfuncs, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_parent", (PyCFunction) pyg_object_info_get_parent, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_property", (PyCFunction) pyg_object_info_get_property, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_ref_function", (PyCFunction) pyg_object_info_get_ref_function, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_set_value_function", (PyCFunction) pyg_object_info_get_set_value_function, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_signal", (PyCFunction) pyg_object_info_get_signal, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_type_init", (PyCFunction) pyg_object_info_get_type_init, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_type_name", (PyCFunction) pyg_object_info_get_type_name, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_unref_function", (PyCFunction) pyg_object_info_get_unref_function, METH_VARARGS | METH_KEYWORDS },
    { "object_info_get_vfunc", (PyCFunction) pyg_object_info_get_vfunc, METH_VARARGS | METH_KEYWORDS },
    { "property_info_get_flags", (PyCFunction) pyg_property_info_get_flags, METH_VARARGS | METH_KEYWORDS },
    { "property_info_get_ownership_transfer", (PyCFunction) pyg_property_info_get_ownership_transfer, METH_VARARGS | METH_KEYWORDS },
    { "property_info_get_type", (PyCFunction) pyg_property_info_get_type, METH_VARARGS | METH_KEYWORDS },
    { "registered_type_info_get_g_type", (PyCFunction) pyg_registered_type_info_get_g_type, METH_VARARGS | METH_KEYWORDS },
    { "registered_type_info_get_type_init", (PyCFunction) pyg_registered_type_info_get_type_init, METH_VARARGS | METH_KEYWORDS },
    { "registered_type_info_get_type_name", (PyCFunction) pyg_registered_type_info_get_type_name, METH_VARARGS | METH_KEYWORDS },
    { "signal_info_get_class_closure", (PyCFunction) pyg_signal_info_get_class_closure, METH_VARARGS | METH_KEYWORDS },
    { "signal_info_get_flags", (PyCFunction) pyg_signal_info_get_flags, METH_VARARGS | METH_KEYWORDS },
    { "signal_info_true_stops_emit", (PyCFunction) pyg_signal_info_true_stops_emit, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_find_method", (PyCFunction) pyg_struct_info_find_method, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_alignment", (PyCFunction) pyg_struct_info_get_alignment, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_field", (PyCFunction) pyg_struct_info_get_field, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_method", (PyCFunction) pyg_struct_info_get_method, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_n_fields", (PyCFunction) pyg_struct_info_get_n_fields, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_n_methods", (PyCFunction) pyg_struct_info_get_n_methods, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_get_size", (PyCFunction) pyg_struct_info_get_size, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_is_foreign", (PyCFunction) pyg_struct_info_is_foreign, METH_VARARGS | METH_KEYWORDS },
    { "struct_info_is_gtype_struct", (PyCFunction) pyg_struct_info_is_gtype_struct, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_array_fixed_size", (PyCFunction) pyg_type_info_get_array_fixed_size, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_array_length", (PyCFunction) pyg_type_info_get_array_length, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_array_type", (PyCFunction) pyg_type_info_get_array_type, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_interface", (PyCFunction) pyg_type_info_get_interface, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_param_type", (PyCFunction) pyg_type_info_get_param_type, METH_VARARGS | METH_KEYWORDS },
    { "type_info_get_tag", (PyCFunction) pyg_type_info_get_tag, METH_VARARGS | METH_KEYWORDS },
    { "type_info_is_pointer", (PyCFunction) pyg_type_info_is_pointer, METH_VARARGS | METH_KEYWORDS },
    { "type_info_is_zero_terminated", (PyCFunction) pyg_type_info_is_zero_terminated, METH_VARARGS | METH_KEYWORDS },
    { "type_tag_to_string", (PyCFunction) pyg_type_tag_to_string, METH_VARARGS | METH_KEYWORDS },
    { "union_info_find_method", (PyCFunction) pyg_union_info_find_method, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_alignment", (PyCFunction) pyg_union_info_get_alignment, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_discriminator", (PyCFunction) pyg_union_info_get_discriminator, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_discriminator_offset", (PyCFunction) pyg_union_info_get_discriminator_offset, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_discriminator_type", (PyCFunction) pyg_union_info_get_discriminator_type, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_field", (PyCFunction) pyg_union_info_get_field, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_method", (PyCFunction) pyg_union_info_get_method, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_n_fields", (PyCFunction) pyg_union_info_get_n_fields, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_n_methods", (PyCFunction) pyg_union_info_get_n_methods, METH_VARARGS | METH_KEYWORDS },
    { "union_info_get_size", (PyCFunction) pyg_union_info_get_size, METH_VARARGS | METH_KEYWORDS },
    { "union_info_is_discriminated", (PyCFunction) pyg_union_info_is_discriminated, METH_VARARGS | METH_KEYWORDS },
    { "value_info_get_value", (PyCFunction) pyg_value_info_get_value, METH_VARARGS | METH_KEYWORDS },
    { "vfunc_info_get_flags", (PyCFunction) pyg_vfunc_info_get_flags, METH_VARARGS | METH_KEYWORDS },
    { "vfunc_info_get_invoker", (PyCFunction) pyg_vfunc_info_get_invoker, METH_VARARGS | METH_KEYWORDS },
    { "vfunc_info_get_offset", (PyCFunction) pyg_vfunc_info_get_offset, METH_VARARGS | METH_KEYWORDS },
    { "vfunc_info_get_signal", (PyCFunction) pyg_vfunc_info_get_signal, METH_VARARGS | METH_KEYWORDS },
    #ifdef PYGIREPOSITORY_FUNCTIONS_CUSTOM_ENTRIES
        PYGIREPOSITORY_FUNCTIONS_CUSTOM_ENTRIES
    #endif
    { NULL, NULL, 0 }
};



static struct PyModuleDef pygirepository_module_def = {
    PyModuleDef_HEAD_INIT,
    "GIRepository",
    NULL,
    -1,
    pygirepository_functions,
    NULL,
    NULL,
    NULL,
    NULL
};

static int
pygirepository_register_types (PyObject *module)
{

    Py_TYPE(&PyGIRepositoryArrayType_Type) = &PyType_Type;
    PyGIRepositoryArrayType_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryArrayType_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryArrayType_Type.tp_methods = PyGIRepositoryArrayType_methods;
    PyGIRepositoryArrayType_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_ARRAY_TYPE__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_ARRAY_TYPE__TYPE_CUSTOM_SETUP(PyGIRepositoryArrayType_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryArrayType_Type))
        return -1;
    if (PyModule_AddObject (module, "ArrayType", (PyObject *)&PyGIRepositoryArrayType_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryArrayType_Type, _enum_value_names, "C", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryArrayType_Type, _enum_value_names, "ARRAY", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryArrayType_Type, _enum_value_names, "PTR_ARRAY", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryArrayType_Type, _enum_value_names, "BYTE_ARRAY", 3);
        PyDict_SetItemString (PyGIRepositoryArrayType_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryAttributeIter_Type) = &PyType_Type;
    PyGIRepositoryAttributeIter_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryAttributeIter_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryAttributeIter_Type.tp_methods = PyGIRepositoryAttributeIter_methods;
    PyGIRepositoryAttributeIter_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_ATTRIBUTE_ITER__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_ATTRIBUTE_ITER__TYPE_CUSTOM_SETUP(PyGIRepositoryAttributeIter_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryAttributeIter_Type))
        return -1;
    if (PyModule_AddObject (module, "AttributeIter", (PyObject *)&PyGIRepositoryAttributeIter_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryBaseInfo_Type) = &PyType_Type;
    PyGIRepositoryBaseInfo_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryBaseInfo_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryBaseInfo_Type.tp_methods = PyGIRepositoryBaseInfo_methods;
    PyGIRepositoryBaseInfo_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_BASE_INFO__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_BASE_INFO__TYPE_CUSTOM_SETUP(PyGIRepositoryBaseInfo_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryBaseInfo_Type))
        return -1;
    if (PyModule_AddObject (module, "BaseInfo", (PyObject *)&PyGIRepositoryBaseInfo_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryDirection_Type) = &PyType_Type;
    PyGIRepositoryDirection_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryDirection_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryDirection_Type.tp_methods = PyGIRepositoryDirection_methods;
    PyGIRepositoryDirection_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_DIRECTION__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_DIRECTION__TYPE_CUSTOM_SETUP(PyGIRepositoryDirection_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryDirection_Type))
        return -1;
    if (PyModule_AddObject (module, "Direction", (PyObject *)&PyGIRepositoryDirection_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryDirection_Type, _enum_value_names, "IN_", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryDirection_Type, _enum_value_names, "OUT", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryDirection_Type, _enum_value_names, "INOUT", 2);
        PyDict_SetItemString (PyGIRepositoryDirection_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryFieldInfoFlags_Type) = &PyType_Type;
    PyGIRepositoryFieldInfoFlags_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryFieldInfoFlags_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryFieldInfoFlags_Type.tp_methods = PyGIRepositoryFieldInfoFlags_methods;
    PyGIRepositoryFieldInfoFlags_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_FIELD_INFO_FLAGS__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_FIELD_INFO_FLAGS__TYPE_CUSTOM_SETUP(PyGIRepositoryFieldInfoFlags_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryFieldInfoFlags_Type))
        return -1;
    if (PyModule_AddObject (module, "FieldInfoFlags", (PyObject *)&PyGIRepositoryFieldInfoFlags_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryFieldInfoFlags_Type, _enum_value_names, "READABLE", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryFieldInfoFlags_Type, _enum_value_names, "WRITABLE", 2);
        PyDict_SetItemString (PyGIRepositoryFieldInfoFlags_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryFunctionInfoFlags_Type) = &PyType_Type;
    PyGIRepositoryFunctionInfoFlags_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryFunctionInfoFlags_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryFunctionInfoFlags_Type.tp_methods = PyGIRepositoryFunctionInfoFlags_methods;
    PyGIRepositoryFunctionInfoFlags_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_FUNCTION_INFO_FLAGS__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_FUNCTION_INFO_FLAGS__TYPE_CUSTOM_SETUP(PyGIRepositoryFunctionInfoFlags_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryFunctionInfoFlags_Type))
        return -1;
    if (PyModule_AddObject (module, "FunctionInfoFlags", (PyObject *)&PyGIRepositoryFunctionInfoFlags_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "IS_METHOD", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "IS_CONSTRUCTOR", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "IS_GETTER", 4);
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "IS_SETTER", 8);
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "WRAPS_VFUNC", 16);
        pygi_codegen_enum_add_value (&PyGIRepositoryFunctionInfoFlags_Type, _enum_value_names, "THROWS", 32);
        PyDict_SetItemString (PyGIRepositoryFunctionInfoFlags_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryInfoType_Type) = &PyType_Type;
    PyGIRepositoryInfoType_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryInfoType_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryInfoType_Type.tp_methods = PyGIRepositoryInfoType_methods;
    PyGIRepositoryInfoType_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_INFO_TYPE__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_INFO_TYPE__TYPE_CUSTOM_SETUP(PyGIRepositoryInfoType_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryInfoType_Type))
        return -1;
    if (PyModule_AddObject (module, "InfoType", (PyObject *)&PyGIRepositoryInfoType_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "INVALID", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "FUNCTION", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "CALLBACK", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "STRUCT", 3);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "BOXED", 4);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "ENUM", 5);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "FLAGS", 6);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "OBJECT", 7);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "INTERFACE", 8);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "CONSTANT", 9);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "INVALID_0", 10);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "UNION", 11);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "VALUE", 12);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "SIGNAL", 13);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "VFUNC", 14);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "PROPERTY", 15);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "FIELD", 16);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "ARG", 17);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "TYPE", 18);
        pygi_codegen_enum_add_value (&PyGIRepositoryInfoType_Type, _enum_value_names, "UNRESOLVED", 19);
        PyDict_SetItemString (PyGIRepositoryInfoType_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryRepository_Type) = &PyType_Type;
    PyGIRepositoryRepository_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryRepository_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryRepository_Type.tp_methods = PyGIRepositoryRepository_methods;
    PyGIRepositoryRepository_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_REPOSITORY__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_REPOSITORY__TYPE_CUSTOM_SETUP(PyGIRepositoryRepository_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryRepository_Type))
        return -1;
    if (PyModule_AddObject (module, "Repository", (PyObject *)&PyGIRepositoryRepository_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryRepositoryClass_Type) = &PyType_Type;
    PyGIRepositoryRepositoryClass_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryRepositoryClass_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryRepositoryClass_Type.tp_methods = PyGIRepositoryRepositoryClass_methods;
    PyGIRepositoryRepositoryClass_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_REPOSITORY_CLASS__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_REPOSITORY_CLASS__TYPE_CUSTOM_SETUP(PyGIRepositoryRepositoryClass_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryRepositoryClass_Type))
        return -1;
    if (PyModule_AddObject (module, "RepositoryClass", (PyObject *)&PyGIRepositoryRepositoryClass_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryRepositoryError_Type) = &PyType_Type;
    PyGIRepositoryRepositoryError_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryRepositoryError_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryRepositoryError_Type.tp_methods = PyGIRepositoryRepositoryError_methods;
    PyGIRepositoryRepositoryError_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_REPOSITORY_ERROR__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_REPOSITORY_ERROR__TYPE_CUSTOM_SETUP(PyGIRepositoryRepositoryError_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryRepositoryError_Type))
        return -1;
    if (PyModule_AddObject (module, "RepositoryError", (PyObject *)&PyGIRepositoryRepositoryError_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryRepositoryError_Type, _enum_value_names, "TYPELIB_NOT_FOUND", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryRepositoryError_Type, _enum_value_names, "NAMESPACE_MISMATCH", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryRepositoryError_Type, _enum_value_names, "NAMESPACE_VERSION_CONFLICT", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryRepositoryError_Type, _enum_value_names, "LIBRARY_NOT_FOUND", 3);
        PyDict_SetItemString (PyGIRepositoryRepositoryError_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryRepositoryLoadFlags_Type) = &PyType_Type;
    PyGIRepositoryRepositoryLoadFlags_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryRepositoryLoadFlags_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryRepositoryLoadFlags_Type.tp_methods = PyGIRepositoryRepositoryLoadFlags_methods;
    PyGIRepositoryRepositoryLoadFlags_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_REPOSITORY_LOAD_FLAGS__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_REPOSITORY_LOAD_FLAGS__TYPE_CUSTOM_SETUP(PyGIRepositoryRepositoryLoadFlags_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryRepositoryLoadFlags_Type))
        return -1;
    if (PyModule_AddObject (module, "RepositoryLoadFlags", (PyObject *)&PyGIRepositoryRepositoryLoadFlags_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryRepositoryLoadFlags_Type, _enum_value_names, "IREPOSITORY_LOAD_FLAG_LAZY", 1);
        PyDict_SetItemString (PyGIRepositoryRepositoryLoadFlags_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryRepositoryPrivate_Type) = &PyType_Type;
    PyGIRepositoryRepositoryPrivate_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryRepositoryPrivate_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryRepositoryPrivate_Type.tp_methods = PyGIRepositoryRepositoryPrivate_methods;
    PyGIRepositoryRepositoryPrivate_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_REPOSITORY_PRIVATE__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_REPOSITORY_PRIVATE__TYPE_CUSTOM_SETUP(PyGIRepositoryRepositoryPrivate_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryRepositoryPrivate_Type))
        return -1;
    if (PyModule_AddObject (module, "RepositoryPrivate", (PyObject *)&PyGIRepositoryRepositoryPrivate_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryScopeType_Type) = &PyType_Type;
    PyGIRepositoryScopeType_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryScopeType_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryScopeType_Type.tp_methods = PyGIRepositoryScopeType_methods;
    PyGIRepositoryScopeType_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_SCOPE_TYPE__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_SCOPE_TYPE__TYPE_CUSTOM_SETUP(PyGIRepositoryScopeType_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryScopeType_Type))
        return -1;
    if (PyModule_AddObject (module, "ScopeType", (PyObject *)&PyGIRepositoryScopeType_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryScopeType_Type, _enum_value_names, "INVALID", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryScopeType_Type, _enum_value_names, "CALL", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryScopeType_Type, _enum_value_names, "ASYNC", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryScopeType_Type, _enum_value_names, "NOTIFIED", 3);
        PyDict_SetItemString (PyGIRepositoryScopeType_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryTransfer_Type) = &PyType_Type;
    PyGIRepositoryTransfer_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryTransfer_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryTransfer_Type.tp_methods = PyGIRepositoryTransfer_methods;
    PyGIRepositoryTransfer_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_TRANSFER__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_TRANSFER__TYPE_CUSTOM_SETUP(PyGIRepositoryTransfer_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryTransfer_Type))
        return -1;
    if (PyModule_AddObject (module, "Transfer", (PyObject *)&PyGIRepositoryTransfer_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryTransfer_Type, _enum_value_names, "NOTHING", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryTransfer_Type, _enum_value_names, "CONTAINER", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryTransfer_Type, _enum_value_names, "EVERYTHING", 2);
        PyDict_SetItemString (PyGIRepositoryTransfer_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryTypeTag_Type) = &PyType_Type;
    PyGIRepositoryTypeTag_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryTypeTag_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryTypeTag_Type.tp_methods = PyGIRepositoryTypeTag_methods;
    PyGIRepositoryTypeTag_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_TYPE_TAG__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_TYPE_TAG__TYPE_CUSTOM_SETUP(PyGIRepositoryTypeTag_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryTypeTag_Type))
        return -1;
    if (PyModule_AddObject (module, "TypeTag", (PyObject *)&PyGIRepositoryTypeTag_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "VOID", 0);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "BOOLEAN", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "INT8", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UINT8", 3);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "INT16", 4);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UINT16", 5);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "INT32", 6);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UINT32", 7);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "INT64", 8);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UINT64", 9);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "FLOAT", 10);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "DOUBLE", 11);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "GTYPE", 12);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UTF8", 13);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "FILENAME", 14);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "ARRAY", 15);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "INTERFACE", 16);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "GLIST", 17);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "GSLIST", 18);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "GHASH", 19);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "ERROR", 20);
        pygi_codegen_enum_add_value (&PyGIRepositoryTypeTag_Type, _enum_value_names, "UNICHAR", 21);
        PyDict_SetItemString (PyGIRepositoryTypeTag_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepositoryTypelib_Type) = &PyType_Type;
    PyGIRepositoryTypelib_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryTypelib_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryTypelib_Type.tp_methods = PyGIRepositoryTypelib_methods;
    PyGIRepositoryTypelib_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_TYPELIB__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_TYPELIB__TYPE_CUSTOM_SETUP(PyGIRepositoryTypelib_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryTypelib_Type))
        return -1;
    if (PyModule_AddObject (module, "Typelib", (PyObject *)&PyGIRepositoryTypelib_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryUnresolvedInfo_Type) = &PyType_Type;
    PyGIRepositoryUnresolvedInfo_Type.tp_repr = (reprfunc)NULL;
    PyGIRepositoryUnresolvedInfo_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryUnresolvedInfo_Type.tp_methods = PyGIRepositoryUnresolvedInfo_methods;
    PyGIRepositoryUnresolvedInfo_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY_UNRESOLVED_INFO__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_UNRESOLVED_INFO__TYPE_CUSTOM_SETUP(PyGIRepositoryUnresolvedInfo_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryUnresolvedInfo_Type))
        return -1;
    if (PyModule_AddObject (module, "UnresolvedInfo", (PyObject *)&PyGIRepositoryUnresolvedInfo_Type))
        return -1;


    Py_TYPE(&PyGIRepositoryVFuncInfoFlags_Type) = &PyType_Type;
    PyGIRepositoryVFuncInfoFlags_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositoryVFuncInfoFlags_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositoryVFuncInfoFlags_Type.tp_methods = PyGIRepositoryVFuncInfoFlags_methods;
    PyGIRepositoryVFuncInfoFlags_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORY_V_FUNC_INFO_FLAGS__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY_V_FUNC_INFO_FLAGS__TYPE_CUSTOM_SETUP(PyGIRepositoryVFuncInfoFlags_Type)
    #endif
    if (PyType_Ready (&PyGIRepositoryVFuncInfoFlags_Type))
        return -1;
    if (PyModule_AddObject (module, "VFuncInfoFlags", (PyObject *)&PyGIRepositoryVFuncInfoFlags_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositoryVFuncInfoFlags_Type, _enum_value_names, "MUST_CHAIN_UP", 1);
        pygi_codegen_enum_add_value (&PyGIRepositoryVFuncInfoFlags_Type, _enum_value_names, "MUST_OVERRIDE", 2);
        pygi_codegen_enum_add_value (&PyGIRepositoryVFuncInfoFlags_Type, _enum_value_names, "MUST_NOT_OVERRIDE", 4);
        pygi_codegen_enum_add_value (&PyGIRepositoryVFuncInfoFlags_Type, _enum_value_names, "THROWS", 8);
        PyDict_SetItemString (PyGIRepositoryVFuncInfoFlags_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    Py_TYPE(&PyGIRepository_Argument_Type) = &PyType_Type;
    PyGIRepository_Argument_Type.tp_repr = (reprfunc)NULL;
    PyGIRepository_Argument_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepository_Argument_Type.tp_methods = PyGIRepository_Argument_methods;
    PyGIRepository_Argument_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY__ARGUMENT__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY__ARGUMENT__TYPE_CUSTOM_SETUP(PyGIRepository_Argument_Type)
    #endif
    if (PyType_Ready (&PyGIRepository_Argument_Type))
        return -1;
    if (PyModule_AddObject (module, "_Argument", (PyObject *)&PyGIRepository_Argument_Type))
        return -1;


    Py_TYPE(&PyGIRepository_BaseInfoStub_Type) = &PyType_Type;
    PyGIRepository_BaseInfoStub_Type.tp_repr = (reprfunc)NULL;
    PyGIRepository_BaseInfoStub_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepository_BaseInfoStub_Type.tp_methods = PyGIRepository_BaseInfoStub_methods;
    PyGIRepository_BaseInfoStub_Type.tp_base = &PyType_Type;
    #ifdef PY_GI_REPOSITORY__BASE_INFO_STUB__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORY__BASE_INFO_STUB__TYPE_CUSTOM_SETUP(PyGIRepository_BaseInfoStub_Type)
    #endif
    if (PyType_Ready (&PyGIRepository_BaseInfoStub_Type))
        return -1;
    if (PyModule_AddObject (module, "_BaseInfoStub", (PyObject *)&PyGIRepository_BaseInfoStub_Type))
        return -1;


    Py_TYPE(&PyGIRepositorynvokeError_Type) = &PyType_Type;
    PyGIRepositorynvokeError_Type.tp_repr = (reprfunc)pygi_codegen_enum_repr;
    PyGIRepositorynvokeError_Type.tp_flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE);
    PyGIRepositorynvokeError_Type.tp_methods = PyGIRepositorynvokeError_methods;
    PyGIRepositorynvokeError_Type.tp_base = &PyLong_Type;
    #ifdef PY_GI_REPOSITORYNVOKE_ERROR__TYPE_CUSTOM_SETUP
        PY_GI_REPOSITORYNVOKE_ERROR__TYPE_CUSTOM_SETUP(PyGIRepositorynvokeError_Type)
    #endif
    if (PyType_Ready (&PyGIRepositorynvokeError_Type))
        return -1;
    if (PyModule_AddObject (module, "nvokeError", (PyObject *)&PyGIRepositorynvokeError_Type))
        return -1;


    {
        PyObject *_enum_value_names = PyDict_New();
        pygi_codegen_enum_add_value (&PyGIRepositorynvokeError_Type, _enum_value_names, "FAILED", 0);
        pygi_codegen_enum_add_value (&PyGIRepositorynvokeError_Type, _enum_value_names, "SYMBOL_NOT_FOUND", 1);
        pygi_codegen_enum_add_value (&PyGIRepositorynvokeError_Type, _enum_value_names, "ARGUMENT_MISMATCH", 2);
        PyDict_SetItemString (PyGIRepositorynvokeError_Type.tp_dict,
                              PYGI_CODEGEN_ENUM_VALUE_NAMES, _enum_value_names);
        Py_DECREF (_enum_value_names);
    }


    return 0;
}

PyObject *
pygirepository_create_module (void)
{
    PyObject *module = PyModule_Create (&pygirepository_module_def);
    if (module == NULL)
        return NULL;

    if (pygirepository_register_types (module)) {
        Py_DECREF (module);
        return NULL;
    }

    return module;
}

